version: '3.8'

services:
  server:
    image: nginx:stable-alpine
    ports:
      - '8000:80'
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/conf.d/default.conf:ro
      # We are picking this folder because in the nginx config (line 5), it's the var www html folder from which 
      # we're serving our content and where we are looking for files. Of course we're looking in the 'public' folder,
      # but that is a folder which exists in the source folder. So binding 'src' to '/var/www/html' is what we need 
      # to do to ensure that our content is made available through that server.
      - ./src:/var/www/html
    depends_on:
      - php
      - mysql  
  php:
    build: 
      context: .
      dockerfile: ./dockerfiles/php.dockerfile
    volumes: 
      - ./src:/var/www/html:delegated
      # ports:
      # The port we need to expose is specified in nginx/nginx.conf (line 12)
      # Notice also that, in that same line (php:3000 - or php:9000 after the update), we use 'php' because that's the name of this service. But
      #  we could've used an IP address too. We are simply taking advantage of the fact that all these containers are 
      # running in the same network by default, so Docker is able to translate the service names.
        # - '9000:3000' 
      # All that being said, we don't need 'ports' here, because all we need is container-to-container communication,
      # so exposing the port to the host is not needed.
  mysql:
    image: mysql:5.7
    env_file:
      - ./env/mysql.env
  composer:
    build: 
      context: .
      dockerfile: ./dockerfiles/composer.dockerfile
    volumes:
      - ./src:/var/www/html  
  # artisan:
  # npm:    